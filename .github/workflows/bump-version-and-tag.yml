name: Bump Version, Tag, and Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: Version string (e.g. 1.5-E)
        required: true

jobs:
  bump-tag-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Get previous tag
        id: previous_tag
        run: |
          CURRENT_VERSION="${{ github.event.inputs.version }}"
          
          # Find all -E pattern tags, sort by creation date, exclude current version
          PREV_TAG=$(git for-each-ref --sort=-creatordate --format='%(refname:short)' refs/tags | \
                     grep -E '^[0-9]+\.[0-9]+-E$' | \
                     grep -v "^${CURRENT_VERSION}$" | \
                     head -1)
          
          if [ -z "$PREV_TAG" ]; then
            echo "No previous tag found"
            echo "tag=" >> $GITHUB_OUTPUT
          else
            echo "tag=${PREV_TAG}" >> $GITHUB_OUTPUT
            echo "Previous tag found: ${PREV_TAG}"
          fi

      - name: Load contributor nicknames
        id: nicknames
        run: |
          if [ -f .github/contributor-nicknames.json ]; then
            echo "nicknames_exist=true" >> $GITHUB_OUTPUT
          else
            echo "nicknames_exist=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate changelog using GitHub API
        id: changelog
        uses: actions/github-script@v7
        with:
          script: |
            const previousTag = '${{ steps.previous_tag.outputs.tag }}';
            const newVersion = '${{ github.event.inputs.version }}';
            const nicknamesExist = '${{ steps.nicknames.outputs.nicknames_exist }}' === 'true';
            
            console.log(`Generating changelog for version ${newVersion}`);
            console.log(`Previous tag: ${previousTag || 'NONE'}`);
            
            // Load contributor nicknames
            let nicknames = {};
            if (nicknamesExist) {
              try {
                const { data: nicknameFile } = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: '.github/contributor-nicknames.json'
                });
                const content = Buffer.from(nicknameFile.content, 'base64').toString('utf8');
                nicknames = JSON.parse(content);
                console.log('Loaded contributor nicknames:', nicknames);
              } catch (error) {
                console.log('Could not load nicknames:', error.message);
              }
            }
            
            let pullRequests = [];
            const contributors = new Set();
            const previousContributors = new Set();
            
            if (previousTag) {
              try {
                // Get contributors from previous tag
                const prevComparison = await github.rest.repos.compareCommitsWithBasehead({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  basehead: `${previousTag}...${previousTag}`,
                  per_page: 1
                });
                
                // Get all PRs up to previous tag to find existing contributors
                const { data: oldPRs } = await github.rest.search.issuesAndPullRequests({
                  q: `repo:${context.repo.owner}/${context.repo.repo} is:pr is:merged`,
                  sort: 'updated',
                  order: 'desc',
                  per_page: 100
                });
                
                for (const pr of oldPRs.items) {
                  if (pr.user && pr.user.login !== 'github-actions[bot]') {
                    previousContributors.add(pr.user.login);
                  }
                }
                
                console.log(`Found ${previousContributors.size} previous contributors`);
                
                // Get commits between tags
                const comparison = await github.rest.repos.compareCommitsWithBasehead({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  basehead: `${previousTag}...main`,
                  per_page: 250
                });
                
                console.log(`Found ${comparison.data.commits.length} commits between ${previousTag} and main`);
                
                const prNumbers = new Set();
                
                for (const commit of comparison.data.commits) {
                  try {
                    const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      commit_sha: commit.sha
                    });
                    
                    for (const pr of prs) {
                      if (pr.merged_at && !prNumbers.has(pr.number)) {
                        prNumbers.add(pr.number);
                        pullRequests.push(pr);
                        
                        if (pr.user && pr.user.login !== 'github-actions[bot]') {
                          contributors.add(pr.user.login);
                        }
                      }
                    }
                  } catch (error) {
                    console.log(`Could not fetch PRs for commit ${commit.sha}: ${error.message}`);
                  }
                }
                
                console.log(`Found ${pullRequests.length} unique PRs`);
                
              } catch (error) {
                console.log(`Error comparing commits: ${error.message}`);
                // For orphaned tags, use empty list
                pullRequests = [];
              }
            } else {
              console.log('No previous tag - fetching recent PRs');
              const { data: recentPRs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed',
                sort: 'updated',
                direction: 'desc',
                per_page: 100
              });
              
              pullRequests = recentPRs.filter(pr => pr.merged_at);
              for (const pr of pullRequests) {
                if (pr.user && pr.user.login !== 'github-actions[bot]') {
                  contributors.add(pr.user.login);
                }
              }
            }
            
            // Find new contributors
            const newContributors = [];
            for (const contributor of contributors) {
              if (!previousContributors.has(contributor)) {
                // Find their first PR in this release
                const firstPR = pullRequests.find(pr => pr.user.login === contributor);
                if (firstPR) {
                  newContributors.push({
                    username: contributor,
                    prNumber: firstPR.number
                  });
                }
              }
            }
            
            console.log(`Found ${newContributors.length} new contributors:`, newContributors);
            
            // Categorize PRs by label and CREATE MARKDOWN LINKS
            const repoUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}`;
            const enhancements = [];
            const bugs = [];
            const documentation = [];
            const other = [];
            
            for (const pr of pullRequests) {
              const labels = pr.labels.map(l => l.name.toLowerCase());
              
              // Skip if marked to exclude from changelog
              if (labels.includes('ignore-for-changelog') || 
                  labels.includes('exclude-from-changelog') ||
                  labels.includes('meta: exclude from changelog')) {
                continue;
              }
              
              // Create markdown links
              const prLink = `[#${pr.number}](${repoUrl}/pull/${pr.number})`;
              const userLink = `[@${pr.user.login}](https://github.com/${pr.user.login})`;
              const prEntry = `- ${pr.title} ${prLink} ${userLink}`;
              
              if (labels.some(l => ['enhancement', 'feature', 'type: enhancement'].includes(l))) {
                enhancements.push(prEntry);
              } else if (labels.some(l => ['bug', 'fix', 'type: bug'].includes(l))) {
                bugs.push(prEntry);
              } else if (labels.some(l => ['documentation', 'docs', 'type: documentation'].includes(l))) {
                documentation.push(prEntry);
              } else {
                other.push(prEntry);
              }
            }
            
            // Create contributor links with nicknames
            const contributorLinks = Array.from(contributors)
              .sort()
              .map(username => {
                const nickname = nicknames[username] || username;
                return `[@${username}](https://github.com/${username}) (${nickname})`;
              })
              .join(', ');
            
            // Create new contributors section
            const newContributorsSection = newContributors
              .map(nc => {
                const nickname = nicknames[nc.username] || nc.username;
                return `* [@${nc.username}](https://github.com/${nc.username}) made their first contribution in [#${nc.prNumber}](${repoUrl}/pull/${nc.prNumber}), welcome to the devs ðŸ«¡`;
              })
              .join('\n');
            
            // Export data
            core.setOutput('enhancements', enhancements.join('\n'));
            core.setOutput('bugs', bugs.join('\n'));
            core.setOutput('documentation', documentation.join('\n'));
            core.setOutput('other', other.join('\n'));
            core.setOutput('contributors', contributorLinks);
            core.setOutput('new_contributors', newContributorsSection);
            core.setOutput('has_new_contributors', newContributors.length > 0 ? 'true' : 'false');
            core.setOutput('pr_count', enhancements.length + bugs.length + documentation.length + other.length);
            
            console.log('Changelog generation complete!');

      - name: Create final changelog file
        env:
          ENHANCEMENTS: ${{ steps.changelog.outputs.enhancements }}
          BUGS: ${{ steps.changelog.outputs.bugs }}
          DOCUMENTATION: ${{ steps.changelog.outputs.documentation }}
          OTHER: ${{ steps.changelog.outputs.other }}
          CONTRIBUTORS: ${{ steps.changelog.outputs.contributors }}
          NEW_CONTRIBUTORS: ${{ steps.changelog.outputs.new_contributors }}
          HAS_NEW_CONTRIBUTORS: ${{ steps.changelog.outputs.has_new_contributors }}
          PR_COUNT: ${{ steps.changelog.outputs.pr_count }}
        run: |
          version="${{ github.event.inputs.version }}"
          version_no_prefix=$(echo "$version" | sed 's/^v//')
          changelog_path="assets/changelogs/$version_no_prefix.md"
          
          mkdir -p assets/changelogs
          
          # Prepare Contributor List
          if [ -n "$CONTRIBUTORS" ]; then
            thank_you_note="A huge thank you to ${CONTRIBUTORS} for their contributions to this update! <3"
          else
            thank_you_note="Thank you to all contributors! <3"
          fi
          
          # Create changelog
          cat > "$changelog_path" << 'EOF'
          ## ðŸŒŸ Ankimon vVERSION_PLACEHOLDER ðŸŒŸ

          THANK_YOU_PLACEHOLDER

          ### What's new

          This release includes PR_COUNT_PLACEHOLDER merged pull requests with enhancements, bug fixes, and improvements!

          ### ðŸ’¢ PSA
          If you love Ankimon, please join our developers ðŸ¥º
          **Dev Guide**: https://h0tp-ftw.github.io/ankimon/

          Feel free to study with us in the **Library VC** in our [Discord](https://discord.gg/Vkvdawxd5s)!

          â€” h0tp ðŸ’–

          ***

          ## ðŸ“œ Full changelog â€” vVERSION_PLACEHOLDER

          EOF
          
          # Add Features & Improvements
          if [ -n "$ENHANCEMENTS" ]; then
            cat >> "$changelog_path" << 'EOF'
          ### âœ¨ Features & Improvements!

          EOF
            printf '%s\n\n' "$ENHANCEMENTS" >> "$changelog_path"
          fi
          
          # Add Bug Fixes
          if [ -n "$BUGS" ]; then
            cat >> "$changelog_path" << 'EOF'
          ### ðŸ› Bug Fixes & Stability!

          EOF
            printf '%s\n\n' "$BUGS" >> "$changelog_path"
          fi
          
          # Add Documentation
          if [ -n "$DOCUMENTATION" ]; then
            cat >> "$changelog_path" << 'EOF'
          ### ðŸ“š Documentation!

          EOF
            printf '%s\n\n' "$DOCUMENTATION" >> "$changelog_path"
          fi
          
          # Add Other changes
          if [ -n "$OTHER" ]; then
            cat >> "$changelog_path" << 'EOF'
          ### ðŸ”§ Other Changes!

          EOF
            printf '%s\n\n' "$OTHER" >> "$changelog_path"
          fi
          
          # Add New Contributors section if there are any
          if [ "$HAS_NEW_CONTRIBUTORS" = "true" ] && [ -n "$NEW_CONTRIBUTORS" ]; then
            cat >> "$changelog_path" << 'EOF'
          ## New Contributors

          EOF
            printf '%s\n\n' "$NEW_CONTRIBUTORS" >> "$changelog_path"
          fi
          
          # Add backup notice
          cat >> "$changelog_path" << 'EOF'
          ***

          Make a backup, but *your progress should NOT BE LOST from updating* - put a bug report if you lose your files

          Backup guide :arrow_right: https://discord.com/channels/1241773562629718148/1303759380768096318

          ***
          EOF
          
          # Replace placeholders
          sed -i "s/VERSION_PLACEHOLDER/${version_no_prefix}/g" "$changelog_path"
          sed -i "s|THANK_YOU_PLACEHOLDER|${thank_you_note}|g" "$changelog_path"
          sed -i "s/PR_COUNT_PLACEHOLDER/${PR_COUNT}/g" "$changelog_path"
          
          echo "Changelog created at: $changelog_path"
          cat "$changelog_path"

      - name: Bump version in manifest.json
        run: |
          version="${{ github.event.inputs.version }}"
          jq --arg ver "$version" '.version = $ver' src/Ankimon/manifest.json > tmp.json && mv tmp.json src/Ankimon/manifest.json
          echo "Updated manifest.json to version: $version"

      - name: Create Pull Request for version bump
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: "Bump version to ${{ github.event.inputs.version }}"
          title: "ðŸš€ Bump version to ${{ github.event.inputs.version }}"
          body: |
            ## Version Bump to ${{ github.event.inputs.version }}
            
            This automated PR bumps the version and includes an auto-generated changelog.
            
            ### âœ… Pre-Merge Checklist
            - [ ] Review the generated changelog in `assets/changelogs/`
            - [ ] Verify `manifest.json` version update is correct
            - [ ] Check that all changes are intentional
            
            ---
            
            ### ðŸ“‹ Post-Merge Steps (REQUIRED)
            
            After you merge this PR, **you must manually create and push the tag** to trigger the release workflow:
            
            ```
            # 1. Update your local main branch
            git checkout main
            git pull origin main
            
            # 2. Create the tag
            git tag ${{ github.event.inputs.version }}
            
            # 3. Push the tag to trigger release workflow
            git push origin ${{ github.event.inputs.version }}
            ```
            
            **Why manual?** For security, only maintainers can create tags that trigger releases.
            
            ---
            
            ### ðŸ“Š Release Summary
            - **Version**: ${{ github.event.inputs.version }}
            - **PRs included**: ${{ steps.changelog.outputs.pr_count }}
            - **Contributors**: ${{ steps.changelog.outputs.contributors }}
            - **New contributors**: ${{ steps.changelog.outputs.has_new_contributors == 'true' && 'âœ¨ Yes!' || 'None' }}
          branch: bump-version-${{ github.event.inputs.version }}
          base: main
          labels: |
            release
            automated
          add-paths: |
            src/Ankimon/manifest.json
            assets/changelogs/
